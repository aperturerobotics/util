// Code generated by protoc-gen-go-lite. DO NOT EDIT.
// protoc-gen-go-lite version: v0.3.1
// source: github.com/aperturerobotics/util/backoff/backoff.proto

package backoff

import (
	binary "encoding/binary"
	io "io"
	math "math"
	strconv "strconv"

	protobuf_go_lite "github.com/aperturerobotics/protobuf-go-lite"
	json "github.com/aperturerobotics/protobuf-go-lite/json"
	errors "github.com/pkg/errors"
)

// BackoffKind is the kind of backoff.
type BackoffKind int32

const (
	// BackoffKind_UNKNOWN defaults to BackoffKind_EXPONENTIAL
	BackoffKind_BackoffKind_UNKNOWN BackoffKind = 0
	// BackoffKind_EXPONENTIAL is an exponential backoff.
	BackoffKind_BackoffKind_EXPONENTIAL BackoffKind = 1
	// BackoffKind_CONSTANT is a constant backoff.
	BackoffKind_BackoffKind_CONSTANT BackoffKind = 2
)

// Enum value maps for BackoffKind.
var (
	BackoffKind_name = map[int32]string{
		0: "BackoffKind_UNKNOWN",
		1: "BackoffKind_EXPONENTIAL",
		2: "BackoffKind_CONSTANT",
	}
	BackoffKind_value = map[string]int32{
		"BackoffKind_UNKNOWN":     0,
		"BackoffKind_EXPONENTIAL": 1,
		"BackoffKind_CONSTANT":    2,
	}
)

func (x BackoffKind) Enum() *BackoffKind {
	p := new(BackoffKind)
	*p = x
	return p
}

func (x BackoffKind) String() string {
	name, valid := BackoffKind_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

// Backoff configures a backoff.
type Backoff struct {
	unknownFields []byte
	// BackoffKind is the kind of backoff.
	BackoffKind BackoffKind `protobuf:"varint,1,opt,name=backoff_kind,json=backoffKind,proto3" json:"backoff_kind,omitempty"`
	// Exponential is the arguments for an exponential backoff.
	Exponential *Exponential `protobuf:"bytes,2,opt,name=exponential,proto3" json:"exponential,omitempty"`
	// Constant is the arugment for a constant backoff.
	Constant *Constant `protobuf:"bytes,3,opt,name=constant,proto3" json:"constant,omitempty"`
}

func (x *Backoff) Reset() {
	*x = Backoff{}
}

func (*Backoff) ProtoMessage() {}

func (x *Backoff) GetBackoffKind() BackoffKind {
	if x != nil {
		return x.BackoffKind
	}
	return BackoffKind_BackoffKind_UNKNOWN
}

func (x *Backoff) GetExponential() *Exponential {
	if x != nil {
		return x.Exponential
	}
	return nil
}

func (x *Backoff) GetConstant() *Constant {
	if x != nil {
		return x.Constant
	}
	return nil
}

// Exponential is the exponential arguments.
type Exponential struct {
	unknownFields []byte
	// InitialInterval is the initial interval in milliseconds.
	// Default: 800ms.
	InitialInterval uint32 `protobuf:"varint,1,opt,name=initial_interval,json=initialInterval,proto3" json:"initial_interval,omitempty"`
	// Multiplier is the timing multiplier.
	// Default: 1.8
	Multiplier float32 `protobuf:"fixed32,2,opt,name=multiplier,proto3" json:"multiplier,omitempty"`
	// MaxInterval is the maximum timing interval in milliseconds.
	// Default: 20 seconds
	MaxInterval uint32 `protobuf:"varint,3,opt,name=max_interval,json=maxInterval,proto3" json:"max_interval,omitempty"`
	// RandomizationFactor is the randomization factor.
	// Should be from [0, 1] as a percentage of the retry interval.
	//
	// randomized interval = RetryInterval * (random value in range [1 - RandomizationFactor, 1 + RandomizationFactor])
	//
	// Default: 0 (disabled)
	RandomizationFactor float32 `protobuf:"fixed32,4,opt,name=randomization_factor,json=randomizationFactor,proto3" json:"randomization_factor,omitempty"`
	// MaxElapsedTime if set specifies a maximum time for the backoff, in milliseconds.
	// After this time the backoff and attached process terminates.
	// May be empty, might be ignored.
	MaxElapsedTime uint32 `protobuf:"varint,5,opt,name=max_elapsed_time,json=maxElapsedTime,proto3" json:"max_elapsed_time,omitempty"`
}

func (x *Exponential) Reset() {
	*x = Exponential{}
}

func (*Exponential) ProtoMessage() {}

func (x *Exponential) GetInitialInterval() uint32 {
	if x != nil {
		return x.InitialInterval
	}
	return 0
}

func (x *Exponential) GetMultiplier() float32 {
	if x != nil {
		return x.Multiplier
	}
	return 0
}

func (x *Exponential) GetMaxInterval() uint32 {
	if x != nil {
		return x.MaxInterval
	}
	return 0
}

func (x *Exponential) GetRandomizationFactor() float32 {
	if x != nil {
		return x.RandomizationFactor
	}
	return 0
}

func (x *Exponential) GetMaxElapsedTime() uint32 {
	if x != nil {
		return x.MaxElapsedTime
	}
	return 0
}

// Constant contains constant backoff options.
type Constant struct {
	unknownFields []byte
	// Interval is the timing to back off, in milliseconds.
	// Defaults to 5 seconds.
	Interval uint32 `protobuf:"varint,1,opt,name=interval,proto3" json:"interval,omitempty"`
}

func (x *Constant) Reset() {
	*x = Constant{}
}

func (*Constant) ProtoMessage() {}

func (x *Constant) GetInterval() uint32 {
	if x != nil {
		return x.Interval
	}
	return 0
}

func (m *Backoff) CloneVT() *Backoff {
	if m == nil {
		return (*Backoff)(nil)
	}
	r := new(Backoff)
	r.BackoffKind = m.BackoffKind
	r.Exponential = m.Exponential.CloneVT()
	r.Constant = m.Constant.CloneVT()
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Backoff) CloneMessageVT() any {
	return m.CloneVT()
}

func (m *Exponential) CloneVT() *Exponential {
	if m == nil {
		return (*Exponential)(nil)
	}
	r := new(Exponential)
	r.InitialInterval = m.InitialInterval
	r.Multiplier = m.Multiplier
	r.MaxInterval = m.MaxInterval
	r.RandomizationFactor = m.RandomizationFactor
	r.MaxElapsedTime = m.MaxElapsedTime
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Exponential) CloneMessageVT() any {
	return m.CloneVT()
}

func (m *Constant) CloneVT() *Constant {
	if m == nil {
		return (*Constant)(nil)
	}
	r := new(Constant)
	r.Interval = m.Interval
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Constant) CloneMessageVT() any {
	return m.CloneVT()
}

func (this *Backoff) EqualVT(that *Backoff) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.BackoffKind != that.BackoffKind {
		return false
	}
	if !this.Exponential.EqualVT(that.Exponential) {
		return false
	}
	if !this.Constant.EqualVT(that.Constant) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Backoff) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Backoff)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Exponential) EqualVT(that *Exponential) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.InitialInterval != that.InitialInterval {
		return false
	}
	if this.Multiplier != that.Multiplier {
		return false
	}
	if this.MaxInterval != that.MaxInterval {
		return false
	}
	if this.RandomizationFactor != that.RandomizationFactor {
		return false
	}
	if this.MaxElapsedTime != that.MaxElapsedTime {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Exponential) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Exponential)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Constant) EqualVT(that *Constant) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.Interval != that.Interval {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Constant) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Constant)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}

// MarshalProtoJSON marshals the BackoffKind to JSON.
func (x BackoffKind) MarshalProtoJSON(s *json.MarshalState) {
	s.WriteEnumString(int32(x), BackoffKind_name)
}

// MarshalText marshals the BackoffKind to text.
func (x BackoffKind) MarshalText() ([]byte, error) {
	return []byte(json.GetEnumString(int32(x), BackoffKind_name)), nil
}

// MarshalJSON marshals the BackoffKind to JSON.
func (x BackoffKind) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// MarshalProtoJSON marshals the Backoff message to JSON.
func (x *Backoff) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.BackoffKind != 0 || s.HasField("backoff_kind") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("backoff_kind")
		x.BackoffKind.MarshalProtoJSON(s)
	}
	if x.Exponential != nil || s.HasField("exponential") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("exponential")
		x.Exponential.MarshalProtoJSON(s.WithField("exponential"))
	}
	if x.Constant != nil || s.HasField("constant") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("constant")
		x.Constant.MarshalProtoJSON(s.WithField("constant"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the Backoff to JSON.
func (x *Backoff) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// MarshalProtoJSON marshals the Exponential message to JSON.
func (x *Exponential) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.InitialInterval != 0 || s.HasField("initial_interval") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("initial_interval")
		s.WriteUint32(x.InitialInterval)
	}
	if x.Multiplier != 0 || s.HasField("multiplier") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("multiplier")
		s.WriteFloat32(x.Multiplier)
	}
	if x.MaxInterval != 0 || s.HasField("max_interval") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("max_interval")
		s.WriteUint32(x.MaxInterval)
	}
	if x.RandomizationFactor != 0 || s.HasField("randomization_factor") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("randomization_factor")
		s.WriteFloat32(x.RandomizationFactor)
	}
	if x.MaxElapsedTime != 0 || s.HasField("max_elapsed_time") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("max_elapsed_time")
		s.WriteUint32(x.MaxElapsedTime)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the Exponential to JSON.
func (x *Exponential) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// MarshalProtoJSON marshals the Constant message to JSON.
func (x *Constant) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Interval != 0 || s.HasField("interval") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("interval")
		s.WriteUint32(x.Interval)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the Constant to JSON.
func (x *Constant) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

func (m *Backoff) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Backoff) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Backoff) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Constant != nil {
		size, err := m.Constant.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.Exponential != nil {
		size, err := m.Exponential.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.BackoffKind != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.BackoffKind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Exponential) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Exponential) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Exponential) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.MaxElapsedTime != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.MaxElapsedTime))
		i--
		dAtA[i] = 0x28
	}
	if m.RandomizationFactor != 0 {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RandomizationFactor))))
		i--
		dAtA[i] = 0x25
	}
	if m.MaxInterval != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.MaxInterval))
		i--
		dAtA[i] = 0x18
	}
	if m.Multiplier != 0 {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Multiplier))))
		i--
		dAtA[i] = 0x15
	}
	if m.InitialInterval != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.InitialInterval))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Constant) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Constant) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Constant) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Interval != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Interval))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Backoff) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BackoffKind != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.BackoffKind))
	}
	if m.Exponential != nil {
		l = m.Exponential.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Constant != nil {
		l = m.Constant.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *Exponential) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InitialInterval != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.InitialInterval))
	}
	if m.Multiplier != 0 {
		n += 5
	}
	if m.MaxInterval != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.MaxInterval))
	}
	if m.RandomizationFactor != 0 {
		n += 5
	}
	if m.MaxElapsedTime != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.MaxElapsedTime))
	}
	n += len(m.unknownFields)
	return n
}

func (m *Constant) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Interval != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.Interval))
	}
	n += len(m.unknownFields)
	return n
}

func (m *Backoff) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: Backoff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: Backoff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field BackoffKind", wireType)
			}
			m.BackoffKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackoffKind |= BackoffKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Exponential", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Exponential == nil {
				m.Exponential = &Exponential{}
			}
			if err := m.Exponential.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Constant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Constant == nil {
				m.Constant = &Constant{}
			}
			if err := m.Constant.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Exponential) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: Exponential: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: Exponential: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field InitialInterval", wireType)
			}
			m.InitialInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitialInterval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return errors.Errorf("proto: wrong wireType = %d for field Multiplier", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Multiplier = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field MaxInterval", wireType)
			}
			m.MaxInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxInterval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 5 {
				return errors.Errorf("proto: wrong wireType = %d for field RandomizationFactor", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RandomizationFactor = float32(math.Float32frombits(v))
		case 5:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field MaxElapsedTime", wireType)
			}
			m.MaxElapsedTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxElapsedTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Constant) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: Constant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: Constant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
